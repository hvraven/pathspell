#ifndef LIBRPG_STORAGE_H
#define LIBRPG_STORAGE_H 1

#include "spell.h"
#include <unordered_map>

namespace RPG
{
  /* needs c++11 template aliases (gcc 4.7/clang 3.0) to compile */
  //  template <class T>
  //  using Storage = std::unordered_map<Identifier, T>;

  // temporary typedef (see above)
  typedef std::unordered_map<Identifier, Pathfinder::Spell> Spell_Storage;

  /**
   * @brief like std::copy, but just generates pointer to original
   * @param first Iterator to the first element to link
   * @param last Iterator one after the last element to link
   * @param d_first Iterator to the beginning of the destination
   * @return iterator behind the last linked element
   */
  template <class InputIterator, class OutputIterator>
  OutputIterator link(InputIterator first, InputIterator last,
                      OutputIterator d_first)
  {
    while (first != last)
      {
        *d_first = &*first;
        ++d_first;
        ++first;
      }

    return d_first;
  }

  /**
   * @brief adds links to all input elements with index to map
   * @param first Iterator to the first element to link
   * @param last Iterator behind the last element to link
   * @param map target. Needs to support subscripting with index
   * generated by ind_gen
   * @param ind_gen Function to generate an index as parameter for the
   * subscripting. Signature should look like std::string
   * ind_gen(const Type& e)
   */
  template <class InputIterator, class Map, class IndexGenerator>
  Map& generate_links_with_index(InputIterator first,
                                 InputIterator last,
                                 Map& map, IndexGenerator ind_gen)
  {
    while (first != last)
      {
        map[ind_gen(*first)] = &*first;
        ++first;
      }
    return map;
  }

} /* namespace RPG */

#endif /* LIBRPG_STORAGE_H */
